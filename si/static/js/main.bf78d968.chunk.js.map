{"version":3,"sources":["units/principles/kiss/assets/kiss.jpg","units/paradigmas/functional/assets/functor.png","units/paradigmas/functional/assets/monad.png","components/welcomepage/index.js","components/welcomepage/welcomepage.js","components/unit/index.js","components/unit/unit.js","components/header/index.js","components/header/header.js","units/paradigmas/oop/index.js","units/paradigmas/oop/oop.js","helperComponent/scrollTo/index.js","helperComponent/scrollTo/sctrollto.js","units/principles/solid/index.js","units/principles/solid/solid.js","units/principles/kiss/index.js","units/principles/kiss/kiss.js","units/paradigmas/functional/index.js","units/paradigmas/functional/functional.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","WelcomePage","Unit","props","slide","condtition","state","toShowlist","setState","listClass","this","lists","topics","map","topic","ind","className","key","to","href","text","onClick","title","React","PureComponent","Header","OOP","Scrollto","scrollto","window","scrollTo","top","left","behavior","Component","Solid","id","width","height","src","frameborder","allow","allowfullscreen","Kiss","style","marginTop","require","position","right","Functional","App","path","component","exact","render","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","StrictMode","document","getElementById","URL","process","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"kOAAAA,EAAOC,QAAU,IAA0B,kC,mBCA3CD,EAAOC,QAAU,IAA0B,qC,mBCA3CD,EAAOC,QAAU,IAA0B,mC,wGCC5BC,ECCK,kBAAK,8F,oCCDVC,E,kDCIZ,WAAYC,GAAO,IAAD,8BACd,cAAMA,IAOVC,MAAQ,WACP,IAAIC,GAAa,EAAKC,MAAMC,WAC5B,EAAKC,SAAS,CAACD,WAAYF,KARxB,EAAKC,MAAM,CACPC,YAAW,GAHD,E,qDAchB,IAAIE,EAAYC,KAAKJ,MAAMC,WAAa,OAAQ,OAC5CI,EAAQD,KAAKP,MAAMS,OAAOC,KAAI,SAACC,EAAOC,GAAR,OAAkB,wBAAIC,UAAaP,EAAWQ,IAAKF,GACrD,kBAAC,IAAD,CAAMG,GAAKJ,EAAMK,MAAOL,EAAMM,UAE9D,OAAU,6BACC,wBAAIC,QAASX,KAAKN,MAAOY,UAAY,oBAAoBN,KAAKP,MAAMmB,OACnEX,O,GArBEY,IAAMC,eCHVC,ECKA,WACb,OAEA,yBAAKT,UAAU,UACX,sFAGA,wBAAIA,UAAU,IACX,kBAAC,EAAD,CAAMM,MAAQ,yDAAYV,OAAU,CAAC,CAACO,KAAK,OAAOC,KAAK,sBAAO,CAACD,KAAK,QAAQC,KAAK,kJACjF,kBAAC,EAAD,CAAME,MAAQ,mDAAWV,OAAU,CAAC,CAACO,KAAK,SAASC,KAAK,SAAS,CAACD,KAAK,QAAQC,KAAK,cCd9EM,ECEH,kBAAM,6BACd,6EACA,kkBACA,2BAAG,62CAGF,sxDAGD,uaACA,2BACA,02PAQA,4lBACA,unBACA,soBACA,4BACA,2BAEA,2BACA,koCAIA,o9BAEA,2BACC,kcACD,8pDAMC,kOACA,kLACA,2KAnBD,siCAsBA,s9BAGA,6BAAK,+jBAGL,kDAEI,6BACI,qgDAMR,0+BAIA,uzBACA,kxBAEI,o1DAEI,6mBACA,6BACA,+uBAEA,6BAAK,+YACL,6BAAK,0gBAGjB,4BACA,yGACA,sfAC2B,kBAAC,IAAD,CAAMR,GAAG,UAAT,SAD3B,oTCjFeS,G,wDCGf,WAAYxB,GAAO,IAAD,8BACd,cAAMA,IAGNyB,SAAW,WACPC,OAAOC,SAAS,CAACC,IAAI,EAAK5B,MAAM4B,IAAIC,KAAK,EAAK7B,MAAM6B,KAAMC,SAAU,YAL1D,E,qDAUd,OAAO,0BAAMjB,UAAU,WAAWK,QAAUX,KAAKkB,UAAWlB,KAAKP,MAAMiB,U,GAXpDG,IAAMW,YCFdC,ECGD,kBAAK,6BACf,gEACA,qLACA,4BAAQC,GAAK,aAAcC,MAAM,MAAMC,OAAO,MAAMC,IAAI,4CACxDC,YAAY,IAAIC,MAAM,0EACrBC,iBAAe,IACf,4BACA,4BACA,6SACA,2BAAG,g/CAIF,4FACA,w1EAMN,8IAEA,+BACI,4BACI,0EACA,iHAEN,4BACE,iCACA,+2CAIF,4BACE,iCACA,6qBAKF,4BACE,iCACA,orCAMF,4BACE,iCACA,yxBAKF,4BACE,iCACA,yuCAOJ,0gBACA,+TAA8D,kBAAC,EAAD,CAAUtB,KAAK,iCAAQW,IAAK,GAAIC,KAAM,IAApG,0IACA,2BAAG,wEACH,wsBAEE,kIACA,iuDAGK,+ZACA,2BACG,07BAGH,4oBAEC,uBAAGb,KAAK,oEAAR,0FACA,4BACA,4FACA,2BACD,8zBAGP,g8BAEA,k2BAEI,4BACJ,6uCAKA,yUACA,oUACA,+sBACA,8xBAEA,8mBAEA,6BACI,4BACJ,g9CAGC,4BACC,k4CAEO,kBAAC,IAAD,CAAMD,GAAG,QAAT,sBAFP,qwCAMA,4BACA,2BAAG,8DACH,mYACA,6BAAK,+4BAED,qwDAII,0kBACA,uBAAGC,KAAK,oEAAR,yCAEF,4BACA,2BAAG,sEACH,2BACI,kXADJ,u8HAYA,2BAAG,22BAEH,2BAAG,mgBAAH,u6FAWI,i9EAQA,uBAAGA,KAAM,oEAAT,+CAEJ,2BAAG,wEACH,yDACA,2BAAG,y+EAQC,mtBAEA,guBAEI,8oDAGI,uBAAGA,KAAM,oEAAT,2CAIlB,2BAAG,uEACH,2BACA,4GAEA,+nBACA,icAGA,63CAEI,8PAFJ,whBAII,uBAAGA,KAAM,oEAAT,2CCzMSwB,ECCF,kBAAM,6BACf,oCAEA,yBAAKC,MAAO,CAACC,UAAU,SAAvB,68EAGA,6BAAK,yBAAKN,IAAKO,EAAQ,IAAsBF,MAAO,CAACP,MAAM,QAAQU,SAAS,WAAWhB,IAAI,EAAEiB,MAAM,KAAnG,KACA,6HACA,qjBARe,0DASL,uBAAG7B,KAAK,wCAAR,sBATK,kiBAYf,0RACA,4sDAEC,omCAIA,0VACA,wBAAIH,UAAU,kBACV,y2CAEA,wnCACA,opDAIJ,ibACA,wBAAIA,UAAU,kBACV,khBACA,spBACA,gcACA,6eACA,wxDAlCU,4GAoCO,uBAAGG,KAAK,oCAAR,kCACpB,+IACA,2BACA,ssBADA,0yIAYA,2BACA,gcADA,qyHAUA,gsBAEG,+OACA,4lCAED,mkCClEO8B,ECEI,kBAAM,6BACrB,uEACA,gZACA,6BAAK,4BAAQZ,MAAM,MAAMC,OAAO,MAAMC,IAAI,4CAA4CC,YAAY,IAAIC,MAAM,0EAA0EC,iBAAe,KACrM,4BACA,6BAAK,4BAAQL,MAAM,MAAMC,OAAO,MAAMC,IAAI,4CAA4CC,YAAY,IAAIC,MAAM,0EAA0EC,iBAAe,KACrM,uHACA,6BACI,6BACI,u+CAIJ,6BACA,2yBADA,+qCAOA,6BACA,+sEAKA,qsDAGwF,q9DAHxF,qjDAUA,wGACA,6BAAK,qKACL,6BAAK,mpBAAL,03BAEmD,yhBAFnD,qTAKA,4BACA,6BAAK,oHACL,6BAAK,61BAAL,knBAGA,6BAAK,qFACD,kwCAGA,4BACD,wBAAI1B,UAAU,kBACT,ikBACA,q3EAIA,2iCAEA,ozCAGL,4BACA,kGACA,2BAAG,svCAGF,2BACA,6JADA,uoBAEuB,mRAFvB,iyBAG4F,slBAH5F,unEAOA,qHAEI,wBAAIA,UAAU,kBACd,4BACA,2BAAG,iLADH,uRAEmD,gmEAFnD,mlBAQA,6BAGA,4BAAI,2BAAG,8RAAP,20EAKI,8BACA,u6DANJ,slCAYC,6BAGD,4BAAI,2BAAG,0PAAP,utFAME,6BAGF,4BAAI,2BAAG,gLAAP,i1BAE8B,spCAE9B,8BAIA,4FACA,4BApHZ,m+OAoIA,4BACA,6BACA,uBAAGG,KAAK,oCAAR,wNAEA,0EACA,8jBACA,2EAAa,kBAAC,EAAD,CAAUC,KAAK,iCAAQW,IAAK,IAAKC,KAAM,IAApD,uIAAoF,uBAAGb,KAAK,oDAAR,4DAApF,UACE,uBAAGA,KAAM,oDAAT,8BADF,8bAIA,gFACA,mrBACI,gfACA,6BAAK,yBAAKoB,IAAKO,EAAQ,OACvB,wmBACA,45CAIJ,oEACA,wjBAEA,6BAAK,yBAAKP,IAAKO,EAAQ,SAGvB,oEACA,q0CAGA,87D,MChJWI,MAjBf,WACE,OACE,kBAAC,IAAD,KACI,kBAAC,IAAD,KACI,yBAAKlC,UAAU,QACX,kBAAC,EAAD,MACA,kBAAC,IAAD,CAAOmC,KAAK,IAAIC,UAAWnD,EAAaoD,OAAK,IAC7C,kBAAC,IAAD,CAAOF,KAAK,OAAOG,OAAQ,kBAAI,kBAAC,EAAD,SAC/B,kBAAC,IAAD,CAAOH,KAAK,QAAQG,OAAQ,kBAAI,kBAAC,EAAD,SAChC,kBAAC,IAAD,CAAOH,KAAK,SAASG,OAAQ,kBAAI,kBAAC,EAAD,SACjC,kBAAC,IAAD,CAAOH,KAAK,QAAQG,OAAQ,kBAAI,kBAAC,EAAD,aCR1CC,EAAcC,QACW,cAA7B3B,OAAO4B,SAASC,UAEe,UAA7B7B,OAAO4B,SAASC,UAEhB7B,OAAO4B,SAASC,SAASC,MACvB,2DAsCN,SAASC,EAAgBC,EAAOC,GAC9BC,UAAUC,cACPC,SAASJ,GACTK,MAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiB/D,QACfyD,UAAUC,cAAcQ,YAI1BC,QAAQC,IACN,iHAKEZ,GAAUA,EAAOa,UACnBb,EAAOa,SAASR,KAMlBM,QAAQC,IAAI,sCAGRZ,GAAUA,EAAOc,WACnBd,EAAOc,UAAUT,WAO5BU,OAAM,SAAAC,GACLL,QAAQK,MAAM,4CAA6CA,MC1FjEC,IAASzB,OACP,kBAAC,IAAM0B,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDYnB,SAAkBpB,GACvB,GAA6C,kBAAmBC,UAAW,CAGzE,GADkB,IAAIoB,IAAIC,IAAwBvD,OAAO4B,SAAStC,MACpDkE,SAAWxD,OAAO4B,SAAS4B,OAIvC,OAGFxD,OAAOyD,iBAAiB,QAAQ,WAC9B,IAAMzB,EAAK,UAAMuB,IAAN,sBAEP7B,IAgEV,SAAiCM,EAAOC,GAEtCyB,MAAM1B,EAAO,CACX2B,QAAS,CAAE,iBAAkB,YAE5BtB,MAAK,SAAAuB,GAEJ,IAAMC,EAAcD,EAASD,QAAQG,IAAI,gBAEnB,MAApBF,EAASG,QACO,MAAfF,IAA8D,IAAvCA,EAAYG,QAAQ,cAG5C9B,UAAUC,cAAc8B,MAAM5B,MAAK,SAAAC,GACjCA,EAAa4B,aAAa7B,MAAK,WAC7BrC,OAAO4B,SAASuC,eAKpBpC,EAAgBC,EAAOC,MAG1Be,OAAM,WACLJ,QAAQC,IACN,oEAvFAuB,CAAwBpC,EAAOC,GAI/BC,UAAUC,cAAc8B,MAAM5B,MAAK,WACjCO,QAAQC,IACN,iHAMJd,EAAgBC,EAAOC,OClC/BE,K","file":"static/js/main.bf78d968.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/kiss.f93f1cb5.jpg\";","module.exports = __webpack_public_path__ + \"static/media/functor.66b08000.png\";","module.exports = __webpack_public_path__ + \"static/media/monad.4fd3b34d.png\";","import WelcomePage from './welcomepage'\r\nexport default WelcomePage","import React from 'react'\r\n\r\nconst WelcomePage = () =><div>Ни день без js!</div>\r\n\r\nexport default WelcomePage","import Unit from './unit'\r\nexport default Unit","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\n\r\n\r\nclass Unit extends React.PureComponent  {\r\n   constructor(props){\r\n       super(props)\r\n       this.state={\r\n           toShowlist:false\r\n       }\r\n   }\r\n\r\n\r\n   slide = () =>{\r\n    let condtition = this.state.toShowlist ? false : true\r\n    this.setState({toShowlist: condtition})\r\n   }\r\n\r\n   render(){\r\n     let listClass = this.state.toShowlist ? 'show' :'hide'\r\n     let lists = this.props.topics.map((topic, ind) =>   <li className = {listClass} key={ind}>\r\n                                     <Link to= {topic.href}>{topic.text}</Link>\r\n                                </li>)\r\n     return    <div>\r\n                <h2 onClick={this.slide} className = 'clickable__title'>{this.props.title}</h2>\r\n                {lists}\r\n            </div>\r\n        }\r\n   }\r\n\r\n\r\n\r\nexport default Unit","import Header from './header'\r\nexport default Header","import React from 'react';\r\nimport './header.css'\r\nimport Unit from '../unit'\r\n\r\n\r\n\r\nconst Header = () => {\r\n  return ( \r\n\r\n  <div className=\"header\">\r\n      <h1>\r\n          Навигация\r\n      </h1>\r\n      <ul className=\"\">\r\n         <Unit title = 'Парадигмы' topics = {[{href:'/oop',text:'ООП'},{href:'/func',text:'Функциональная парадигма'}]}/>\r\n         <Unit title = 'Принципы' topics = {[{href:'/solid',text:'SOLID'},{href:'/kiss',text:'KISS'}]}/>\r\n      </ul>\r\n  </div>\r\n\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import OOP from './oop'\r\nexport default OOP","import React from 'react'\r\nimport {Link} from 'react-router-dom';\r\n\r\nconst OOP = () => <div>\r\n    <h2>Итак, ооп!</h2>\r\n    <p>Начнем с сухих определений. Далеко лазить не будем. Откроем википедию и посмотрим что она скажет нам об ООП</p>\r\n    <p><strong>Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности\r\n     объектов,\r\n     каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</strong></p>\r\n     <p>Спасибо, википедия, из этого мы можем сделать вывод что ООП оперирует обьектами, каждый объект несет ряд свойств и характеристик, по которым их \r\n        можно объеденить. Тоесть у кажого объекта есть свой класс. Мы можем создавать новые объекты, наделяя их определенным классом. Это значит\r\n        что новый объект получит(унаследует) всю мощь объекта - прородителя</p>\r\n    <p>Хорошо. Но мы, как умные ребята и правильные посоны изучим и другие источники</p>\r\n    <p>\r\n    <strong>\r\n    Центральными в ООП являются понятия класса и объекта. Образно говоря, ООП заключается не столько в использовании классов и объектов в программе, сколько в замене принципа программирования \"от функции к функции\" принципом программирования \"от класса к классу\".\r\n    Технология ООП прежде всего накладывает ограничения на способы представления данных в программе. Любая программа отражает в них состояние физических предметов либо абстрактных понятий (назовем их объектами программирования), для работы с которыми она предназначена. В традиционной технологии варианты представления данных могут быть разными. В худшем случае программист может \"равномерно размазать\" данные о некотором объекте программирования по всей программе. В противоположность этому все данные об объекте программирования и его связях с другими объектами можно объединить в одну структурированную переменную. В первом приближении ее можно назвать объектом. Кроме того, с объектом связывается набор действий, иначе называемых методами. С точки зрения языка программирования это функции, получающие в качестве обязательного параметра указатель на объект. Технология ООП запрещает работать с объектом иначе, чем через методы, то есть внутренняя структура объекта скрыта от внешнего пользователя. Описание множества однотипных объектов называется классом.\r\n    Объект - структурированная переменная, содержащая всю информацию о некотором физическом предмете или реализуемом в программе понятии.\r\n    Класс - описание множества таких объектов и выполняемых над ними действий.\r\n    </strong>\r\n    </p>\r\n\r\n    <p>Очень хорошо, так мы приходим к пониманию, что ООП это не столько про классы, сколько про СПОСОБ ОРГАНИЗАЦИИ КОДА</p>\r\n    <p>Чтобы разобраться какие преймущества дает этот подход, рассмотрим основные ПРИНЦИПЫ ООП. Ты наверняка о них слышал </p>\r\n    <p>По классике выделяют 3 принципа. Но в некоторых источниках число доходит до 8. Обозначим четыре. Добавим абстрагирование</p>\r\n    <p></p>\r\n    <p>\r\n  \r\n    <p>\r\n    <div>\r\n    Начну с абстрагирования. Это очень важное в ООП понятие. Так как именно оно лежит в основе возможности расширения приложений. \r\n        В основе классов тоже лежит некая астракция(интерфейс), которая реализуется в наследовании\r\n    </div>\r\n    <strong>Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения не значимые.Соответственно, абстракция — это набор всех таких характеристик. </strong>\r\n    </p>\r\n    <p>\r\n     <div>Наследование. Тут более-менее все должно быть ясно, хотя бы на интуитивном уровне.</div> \r\n    <strong>\r\n    Наследование — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью\r\n     заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, \r\n     родительским или суперклассом. Новый класс — потомком, наследником или производным классом\r\n     </strong>\r\n     </p>\r\n     <div>Ну и классический пример с машинками. </div>\r\n     <div>У нас есть класс - автомобиль.</div>\r\n     <div>И дочерний класс - хэтчбеки.</div>\r\n    Хэтчбэки наследуют у автомобиля 4 колеса, выхлопную трубу, способность ездить и прочие базовые характеристики и умения автомобиля. При этом у него будут свои характеристики, свойственные именно хэтчбеку.\r\n    </p>\r\n    <p>\r\n    С инкапсуляцией есть некоторые тонкости. Часто выделяют СОКРЫТИЕ ДАННЫХ как основной смысл инкапсуляции, однако же сокрытие есть важный побочный \r\n    продукт инкапсуляции. Суть в том, что\r\n    <div><strong>\r\n    Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе\r\n    </strong></div>\r\n    <div>\r\n        или\r\n        <div>\r\n            <strong>\r\n            В информатике размещение в одном компоненте данных и методов, которые с ними работают. Также может означать скрытие внутренней реализации от других компонентов. \r\n            Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения и изменения её значения\r\n            </strong>\r\n        </div>\r\n    </div>\r\n    <div>Инкапсуляция повзоляет выстраивать архитектуру. Разбивать на отдельные модули. Предоставляет возможность удобства в пользовании компонентами.\r\n        Обеспечивает безопасность сокрытием.\r\n    </div>\r\n    </p>\r\n    <p>И наконец, его величество полиорфизм. Страшный дядька, которого в некоторых источниках выделяют как столп ООП, называя принципы выше лишь его подспорьем.\r\n    <div>Может, так оно и есть. Ведь именно полиморфизм задает ноту универсальности интерфейсов. Позволяет выстраивать гибкую и расширяемую архитектуру.\r\n        </div> \r\n        <div>Ведь основной смысл ООП в том, что благодаря ему мы можем превратить скромный туду-лист в сложный многофункциональный органайзер по типу jira. При этом не сойдя с ума от того, что на каком-то этапе\r\n            новый функционал добавлять стало невроятно сложно, баги сыпятся как из рога страданий,отловить их не может даже Чак Норрис, а запутаться в коде могут не только лишь все. </div>\r\n            <div>Определений, как и типов полиморфизма много. Пока не буду на этом заострять внимание. Приведу наиболее лакончиные</div>\r\n            <div>\r\n            <strong>Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</strong>\r\n            </div>\r\n            <div><strong>Полиморфизм — способность функции обрабатывать данные разных типов.</strong></div>\r\n            <div><strong>Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.</strong></div>\r\n </p>\r\n\r\n<p></p>\r\n<p>Подведем итог.</p>\r\n<p>Смысл ООП - выстраивании гибкой, расширяемой и надежной архитектуры. \r\n    Но основе ООП строится <Link to='/solid'>solid</Link>. Которые повсеместно используются в создании приложений.</p>\r\n</div>\r\n\r\nexport default OOP","import Scrollto from './sctrollto'\r\nexport default Scrollto","import  React from 'react'\r\nimport './scrollto.scss'\r\n\r\nclass Scrollto extends React.Component{\r\nconstructor(props){\r\n    super(props)\r\n    }\r\n\r\n    scrollto = () =>{\r\n        window.scrollTo({top:this.props.top,left:this.props.left, behavior: \"smooth\"})\r\n    }\r\n\r\n\r\n    render(){\r\n    return <span className='scroller' onClick ={this.scrollto}>{this.props.text}</span>\r\n    }\r\n}\r\n\r\nexport default Scrollto","import Solid from './solid'\r\nexport default Solid","import React from 'react'\r\nimport ScrollTo from '../../../helperComponent/scrollTo'\r\nimport {Link} from 'react-router-dom';\r\n\r\nconst Solid = () =><div>\r\n    <h2>Итак, solid!</h2>\r\n    <h3>Хорошее видево от тов. Минина</h3>\r\n    <iframe id ={'mininsolid'} width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/xq13wiqvcTc\" \r\n    frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\r\n     allowfullscreen></iframe>\r\n     <p></p>\r\n     <p></p>\r\n     <h3>Ну а начнем, пожалуй, по традиций с определений и вики</h3> \r\n     <p><strong>SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion)\r\n     в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers)\r\n      для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов \r\n      объектно-ориентированного программирования и проектирования.</strong></p>\r\n      <h3>Назначение</h3>\r\n      <p>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать \r\n          и расширять в течение долгого времени. Принципы SOLID — это руководства, которые также могут применяться во время работы над \r\n        существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».\r\n\r\nСтратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.</p>\r\n\r\n<h3>Сами принципы КРАТКО</h3>\r\n\r\n<table>\r\n    <tr>\r\n        <th>Инициал</th>\r\n        <th>Название и суть</th>\r\n    </tr>\r\n  <tr>\r\n    <td>S</td>\r\n    <td>Принцип единственной ответственности (The Single Responsibility Principle)\r\n    Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. \r\n    Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.</td>\r\n  </tr>\r\n  <tr>\r\n    <td>O</td>\r\n    <td>\r\n    Принцип открытости/закрытости (The Open Closed Principle)\r\n    «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>L</td>\r\n    <td>\r\n    Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)\r\n    «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»\r\n    Наследующий класс должен дополнять, а не изменять базовый.\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>I</td>\r\n    <td>\r\n    Принцип разделения интерфейса (The Interface Segregation Principle)\r\n    «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>D</td>\r\n    <td>\r\n    Принцип инверсии зависимостей (The Dependency Inversion Principle)\r\n    Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\r\n    Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\r\n    </td>\r\n  </tr>\r\n</table>\r\n<h3>Звучит несомненно замечательно. Но что со всем эти делать?(кроме как выпендриваться на собесах)</h3>\r\n<p>Тов. Минин, я вызываю тебя! Далее материал будет на основе <ScrollTo text='урока' top={20} left={0} /> ибо хорошо разложено для js </p>\r\n<p><strong>The Single Responsibility Principle</strong></p>\r\n<p>Суть такова: если надо расширить класс новым функционалом. Добавить новое поведение.\r\n  Лучше вынести это поведение в отдельный класс.</p> \r\n  <p>И пример от маэстро</p>\r\n  <p>Ниже описывается класс news. В нем инкапсулированы только те сущности, котроые отвечают непосредственно за новость: контент и возможность\r\n       обновления. С этой новостью мы можем делать что хотим: отобразить на странице в html, передать в json, xml и тд. И можно в классе news задать \r\n       методы обработки в нужный формат. Можно, да. Тогда мы будем нарушать наш принцип.\r\n       <strong>Почему это не хорошо? Почему следует вынести обработчик в одельный класс?</strong></p>\r\n       <p>\r\n          <strong> \r\n       Во первых мы не перегружаем сам класс. Он остается лаконичным и понятным. Во вторых мы создаем универсальный класс -обрабочтик, \r\n       которым могут пользоваться другие классы, помимо news. </strong>\r\n       <div> ->В примере обработчик конренто для news и принимает экземпляр news. Но чисто теоретически можно эктраполировать на что угодно.</div>\r\n       </p>\r\n        <a href='https://github.com/vladilenm/SOLID_javascript/blob/master/1_S.js'>Ссылка на пример</a>\r\n        <p></p>\r\n        <p>Мнение вики</p>\r\n        <p>\r\n       <strong>Возникает вопрос, когда стоит использовать этот принцип? Всё же принцип — это не закон и SRP стоит применять в\r\n        зависимости от того, как изменяется приложение:</strong></p>\r\n\r\n<div> -если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, \r\n    отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.</div>\r\n<div> -если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, \r\n    то этот принцип можно не применять.</div>\r\n    <p></p>\r\n<p>\r\nСлепое следование принципу единственной ответственности приводит к избыточной сложности приложения,\r\n его поддержки и тестирования. SRP стоит применять только тогда, когда это оправдано.\r\n  Принцип SRP можно применить только в том случае, когда:</p>\r\n\r\n<div> -объекту класса становится позволительно слишком много;</div>\r\n<div> -доменная логика концентрируется только в одном классе;</div>\r\n<div> -любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;</div>\r\n<div> -приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья\r\n     сторона;</div>\r\n<div> -невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.</div>\r\n\r\n<div>\r\n    <p></p>\r\n<strong>Объединение ответственностей является общепринятой практикой и в этом нет ничего плохого,\r\n до тех пор пока это легко обслуживать. Следование принципу единственной ответственности зависит от функций \r\n программного продукта и является труднейшим при проектировании приложений.</strong></div>\r\n <p></p>\r\n  <p>Прочитав все и ознакомившись с примером, ты дорогой читатель мог и запутаться. Когда стоит, а когда не стоит применять этот принцип в js.\r\n      Понимание придет с опытом. На мой взляд не стоит пихать этот принцип всюду и дробить все подряд. Как критерием может послужить момент \r\n      из <Link to='/oop'>ооп</Link>. А именно абстрагирование. Насколько поведение можно назвать значимым неосредственно \r\n      для конкретного класса. И можно ли это поведение \r\n      абстрагировать от класса и применить к другому классу. Если нет\\да - то тогда можно применить принцип. (Мое мнение)\r\n  </p>\r\n  <p></p>\r\n  <p><strong>The Open Closed Principle</strong></p>  \r\n  <p>Классы должны быть ОТКРЫТЫ для РАСШИРЕНИЯ и ЗАКРЫТЫ для МОДИФИКАЦИИ\r\n  <div><strong>Смысл принципа в том, что мы выстраиваеи код таким образом, что если нам протребуется добавить какие-либо возможности и новый функционал \r\n      то мы НЕ ПЕРЕПИСЫВАЕМ старый код.</strong>\r\n      <p>\r\n          В примере у нас есть фигуры и класс, который считает площади. Этот класс мог бесконечно модифицироваться ифами с появлением новых классов фигур.\r\n          Это больно. Поэтому мы не переписываем логику класса площадей, а вводим базовый класс для фигур, который повзоляет возвращать площадь. А класс площадей\r\n          универсально их принимает и выдает результат.\r\n          <strong>Каждая новая фигура требует РАСШИРЕНИЕ числa дочерних классов фигуры, а не МОДИФИЦИКАЦИИ класса площадей.</strong>\r\n          <a href='https://github.com/vladilenm/SOLID_javascript/blob/master/2_O.js'>Пример</a>\r\n      </p>\r\n        <p></p>\r\n        <p><strong>The Liskov Substitution Principle</strong></p> \r\n        <p>\r\n            <div>Вики подкидывает нам размышления несколько философского толка:</div>\r\n        Принцип Барбары Лисков заставляет задуматься о том, что такое «декларация типа» в терминах \r\n        объектно-ориентированного языка программирования, который мы используем. Достаточно ли нам описать интерфейс объекта\r\n         с помощью обычного абстрактного класса со списком методов, типами параметров и возвращаемого значения? Каким образом мы можем \r\n         декларировать требования к значениям параметров метода и свойства, которыми будет обладать возвращаемое значение? Как нам описать \r\n         исключения, которые может сгенерировать метод во время выполнения? Как нам описать изменение состояния объекта на разных этапах его\r\n          жизненного цикла?\r\n        Задавая себе эти вопросы и находя ответы, можно спроектировать систему, которая действительно будет удовлетворять \r\n        принципу подстановки \r\n    Барбары Лисков.\r\n        </p>\r\n        <p><strong>Роберт С. Мартин определил этот принцип так:\r\n            Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.</strong></p>\r\n        <p><div>Cуть в том, что функция должна уметь работать как с базовым типом, так с его потомками одинаково. \r\n            </div>Тов. Минин привел пример с классом Person\r\n             от которого\r\n            наследуются сотрудники двух разных компаний. Одни имеют доступ к секретной двери. Другие нет. \r\n            Так вот функция, которая проверяет на доступ выбрасывае ошибку\r\n            на тех ребятах, которые из другой компании. Хотя принимает она во всех случаях person. \r\n            Ведь именно класс person содержит инфу о ключе.\r\n            Это и нарушает принцип Liskov substitution. Для решения проблемы мы вводим новый уровень\r\n            абстракции. Person получает двух наследников. Собтсвенно члены компании и гости. И уже на этом уровне,\r\n             в этих двух классах мы и определяем ключи.\r\n            А секретная дверь будет работать уже с ними.\r\n            <div>Во втором примере показана работа с компонентами. Когда компоненты разных типов наследовались от класса components который содержал render\r\n                 метод.\r\n                Проблема возникла, когда появился hoc, тоесть компонент который \"отключает\" рендер, так как мы знаем что hocи не имеют редер\\а \r\n                если не знаем читаем\\. \r\n                Соответсвенно на функции rendercomponent, которая использовала render от components выбрасывается ошибка. Алгоритм аналогичный - вводим новый уровень абстракции и переносим render туда\r\n                где он нужен. RenderComponent будет работать только с этим классом.\r\n\r\n            </div>\r\n            <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/3_L.js'>Примеры</a>\r\n        </p>\r\n        <p><strong>The Interface Segregation Principle</strong></p> \r\n        <div>Вики</div>\r\n        <p><strong>\r\n        Роберт С. Мартин определил этот принцип так:\r\n\r\nПрограммные сущности не должны зависеть от методов, которые они не используют.\r\nПринцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические,\r\n чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода \r\n интерфейса не должны меняться программные сущности, которые этот метод не используют.\r\n            </strong>\r\n            <div>Следование этому принципу помогает системе оставаться гибкой при внесении изменений в логику работы и пригодной для рефакторинга.</div>\r\n            </p>\r\n            <p>Суть в том, что если наследник не использует метод, который он получил от родителя, использует не корректно, \r\n                значит мы сделали что-то не так</p>\r\n                <div>Тов. Минин привел очень наглядный пример с животными. Базовый класс Animal содержал в себе методы- спосбности животных.\r\n                    Но наследник собака не умеет летать. А такой метод есть в базоом классе. Пришлось \"обнулять\" его.\r\n                    Вместо этого автор предложил использовал композицию, благодаря которой можно добавлять только нужные умения.\r\n                    <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/4_I.js'>Пример</a>\r\n                </div>\r\n  </div>\r\n  </p>\r\n  <p><strong>The Dependency Inversion Principle</strong></p> \r\n  <p>\r\n  <strong>\r\n  Формулировка:\r\n  <div>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</div>\r\n  <div>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</div>\r\n  </strong>\r\n  </p>\r\n  <p>Тов. Минин привел живой пример, где база данных получала данные из разных источников. Первоначально это был условный фетч. \r\n      И класс ДБ первоначально вызывал экземпляр фетча. Но потом вяснилось что данные подтягиваются с локалстараджа, поэтому ДБ пришлось переписать.\r\n      <div>На лицо зависимость абстракции от деталей</div>\r\n      Устраняем это введением новых абстракций, отвечающих за конкретный тип, с которыми и будет работать ДБ.\r\n      <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/5_D.js'>Пример</a>\r\n      </p>\r\n</div>\r\n\r\nexport default Solid","import Kiss from './kiss'\r\nexport default Kiss","import React from 'react'\r\n\r\nconst Kiss = () => <div>\r\n    <h3>KISS</h3>\r\n\r\n    <div style={{marginTop:'70px'}}>\r\n    KISS (акроним для «Keep it simple, stupid») — принцип проектирования, принятый в ВМС США в 1960. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности. Фраза ассоциировалась с авиаконструктором Кларенсом Джонсоном (1910—1990)[3]. В 1970-х гг. широко использовался термин «KISS-принцип» (англ. KISS principle)[4]. Вариации на фразу включают «англ. Keep it Simple, Silly», «keep it short and simple», «keep it simple and straightforward» и «keep it small and simple».\r\n    </div>\r\n    <div><img src={require('./assets/kiss.jpg')} style={{width:'130px',position:'absolute',top:0,right:0}}/> </div>\r\n    <p>Итак. Что же такое KISS?</p>\r\n    <p>Это не только замечательный вокально-инструментальный ансамбль,но и важный для разработчика принцип</p>\r\n    Расписано <a href='https://web-creator.ru/articles/kiss'>тут</a> Но для тех кому лень переходить по ссылку скопипастю. Ибо смысла \r\n    пояснять что-либо нет.\r\n    Все предельно ясно.\r\n    <h3>Принцип программирования KISS — делайте вещи проще</h3>\r\n    <p>Большая часть программных систем необосновано перегружена практически ненужными функциями, что ухудшает удобство их использование конечными пользователями, а также усложняет их поддержку и развитие разработчиками.\r\n     Следование принципу «KISS» позволяет разрабатывать решения, которые просты в использовании и в сопровождении.</p>\r\n     <p>\r\n     KISS — это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. \r\n     Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple».\r\n     </p>\r\n     <h3>В проектировании следование принципу KISS выражается в том, что:</h3>\r\n     <ul className='list_style row'>\r\n         <li>не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или их использование крайне маловероятно,\r\n              как правило, большинству пользователей достаточно базового функционала, а усложнение только вредит удобству приложения;</li>\r\n         <li>не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей, гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от данного функционала);</li>\r\n         <li>\r\n         бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно, а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с коммерческой точки зрения.\r\n         </li>\r\n     </ul>\r\n     <h3>В программировании следование принципу KISS можно описать так(наматываем на ус!):</h3>\r\n     <ul className='list_style row'>\r\n         <li>не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;</li>\r\n         <li>бессмысленно закладывать в проект избыточные функции «про запас», которые может быть когда-нибудь кому-либо понадобятся</li>\r\n         <li>не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара функций;</li>\r\n         <li>декомпозиция чего-то сложного на простые составляющие — это архитектурно верный подход</li>\r\n         <li>абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов, данные можно и нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме.</li>\r\n      </ul>   \r\n      Размышления по теме <a href='https://habr.com/ru/post/249639/'>Здесь</a>\r\n      <p>Мякотка с этой статьи:</p>\r\n      <p>\r\n      <strong>Итак, принцип проектирования KISS (keep it simple and straightforward) провозглашает, что простота кода – превыше всего, \r\n      потому что простой код – наиболее понятный.</strong>\r\n      Практически все принципы проектирования направлены на достижение понятности кода. Нарушая какой-либо принцип проектирования, \r\n        вы уменьшаете понятность кода. Непонятный код автоматически вызывает у человека ощущение того, что код сложный, так как его сложно понимать\r\n        и модифицировать. При нарушении любого из этих принципов также нарушается и принцип KISS. Поэтому можно говорить, что KISS включает почти\r\n     все остальные принципы проектирования.\r\n    Патерны проектирования описывают наиболее удачные, простые и понятные решения некоторых проблем. \r\n    Если вы используете паттерн проектирования там, где нет проблемы, которую решает данный паттерн – \r\n    то вы нарушаете KISS, внося ненужные усложнения в код. Если вы НЕ используете паттерн проектирования там, где есть проблема, \r\n    соответствующая паттерну – то вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.\r\n      </p>\r\n      <p>\r\n      <strong>На мой взгляд, принцип KISS может быть полезен лишь для начинающих проектировщиков</strong>, которые не знают или не понимают основных принципов \r\n      проектирования. KISS защищает от неверного использования принципов проектирования и паттернов. Поскольку принципы и паттерны предназначены \r\n      для увеличения понятности кода, то их правильное использование не может привести к уменьшению понятности кода. Однако если вы неверно\r\n       понимаете принцип проектирования (например, истолковываете «не плодите лишних сущностей» как «плодите как можно меньше сущностей»), \r\n       или соблюдая один принцип нарушаете десяток других, то KISS может стать для вас надёжной подушкой безопасности. В остальных случаях \r\n       от KISS-а мало толку, т.к. он слишком общий и абстрактный. Остальные же принципы более конкретны и содержат более явные пути к \r\n       достижению понятности и простоты кода.\r\n      </p>\r\n\r\n      <p>\r\n        Всвязи с тем, что представления разных людей о таком понятии как «простота» могут различаться, приобрели широкое распространение\r\n         <strong> следующая заблуждения относительно KISS-a:</strong>\r\n         <div> Заблуждение 1. Если считать, что простой код – это такой код, который проще всего написать, то можно истолковать, что принцип \r\n        KISS призывает писать первое что взбредёт в голову, вообще не задумываясь о проектировании.</div>\r\n        <div>Заблуждение 2. Если считать, что простой код – это такой код, для написания которого требуется как можно меньше знаний, \r\n        то можно истолковать, что принцип KISS призывает не использовать паттерны проектирования. </div>\r\n      </p>\r\n</div>\r\n\r\nexport default Kiss\r\n","import Functional from './functional'\r\nexport default Functional","import React from 'react'\r\nimport ScrollTo from '../../../helperComponent/scrollTo'\r\n\r\nconst Functional = () => <div>\r\n    <h3>Итак, ФП!</h3>\r\n    <h3>Полезные видео по ФП в джс, сравнение имеративного и фс. Функторы, монады</h3>\r\n    <div><iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/0JxSs_GcvbQ\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>\r\n    <b></b>\r\n    <div><iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/3Z7f0Gi8pxw\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>\r\n    <h3>Вики говорит нам:</h3>\r\n    <div>\r\n        <div>\r\n            <strong>Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется\r\n            как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном \r\n            программировании).</strong>\r\n        </div>\r\n        <div>\r\n        <strong>Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение \r\n            состояний </strong>\r\n            (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность \r\n            последовательных\r\n            состояний вычислительного процесса представляется явным образом, например, как список.\r\n        </div>\r\n        <div>\r\n        <strong>Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций,\r\n            и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния \r\n            (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая \r\n            менять его по мере выполнения алгоритма).</strong>\r\n        </div>\r\n        <div>\r\n            На практике отличие математической функции от понятия «функции» в императивном программировании заключается в том, \r\n            что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции переменных,\r\n            а также иметь побочные эффекты и менять состояние внешних переменных. Таким образом,<strong> в императивном программировании при вызове одной и \r\n            той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за \r\n            влияния на функцию состояния переменных. А в функциональном языке при вызове функции с одними и теми же аргументами мы всегда получим \r\n            одинаковый результат: выходные данные зависят только от входных.</strong> Это позволяет средам выполнения программ на функциональных языках \r\n            кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо дополнительных \r\n            действий со стороны программиста (что обеспечивают функции без побочных эффектов — чистые функции).\r\n        </div>\r\n        <h3>Терминология</h3>\r\n        <div><strong>Функции высших порядков</strong></div>\r\n        <div><strong>Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и возвращать другие функции</strong>.\r\n            Математики такую функцию чаще называют оператором, например, оператор взятия производной или оператор интегрирования.\r\n            Функции высших порядков позволяют использовать <strong>карринг — преобразование функции от пары аргументов в функцию, \r\n            берущую свои аргументы по одному.</strong> Это преобразование получило своё название в честь Х. Карри.\r\n        </div>\r\n        <p></p>\r\n        <div><strong>Чистые функции</strong></div>\r\n        <div><strong> Чистыми называют функции, которые не имеют побочных эффектов ввода-вывода и памяти (они зависят только от своих параметров \r\n            и возвращают только свой результат).</strong> Чистые функции обладают несколькими полезными свойствами, многие из которых можно \r\n            использовать для оптимизации кода:</div>\r\n        <div><strong>Рекурсия</strong></div>\r\n            <div>В функциональных языках цикл обычно реализуется в виде рекурсии. Строго говоря, в функциональной парадигме\r\n            программирования нет такого понятия, как цикл. Рекурсивные функции вызывают сами себя, \r\n            позволяя операции выполняться снова и снова. </div>\r\n            <p></p>\r\n           <ul className='row list_style'>\r\n                <li>Если результат чистой функции не используется, её вызов может быть удалён без вреда для других выражений.</li>\r\n                <li>Результат вызова чистой функции может быть мемоизирован, то есть сохранён в таблице значений вместе с аргументами вызова. \r\n                    Если в дальнейшем функция вызывается с этими же аргументами, её результат может быть взят прямо из таблицы, не вычисляясь \r\n                    (иногда это называется принципом прозрачности ссылок). Мемоизация, ценой небольшого расхода памяти, позволяет существенно увеличить \r\n                    производительность и уменьшить порядок роста некоторых рекурсивных алгоритмов.</li>\r\n                <li>Если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их вычисления можно поменять или распараллелить\r\n                    (говоря иначе вычисление чистых функций удовлетворяет принципам thread-safe)</li>\r\n                <li>Если весь язык не допускает побочных эффектов, то можно использовать любую политику вычисления. Это предоставляет свободу\r\n                    компилятору комбинировать и реорганизовывать вычисление выражений в программе (например, исключить древовидные структуры).</li>\r\n           </ul>\r\n           <p></p>\r\n           <h3>Особенности</h3>\r\n           <p><strong>Императивные программы имеют склонность акцентировать последовательности шагов для выполнения какого-то действия, \r\n               а функциональные программы к расположению и композиции функций, часто не обозначая точной последовательности шагов\r\n               </strong></p>\r\n            <p>\r\n            <strong>Основной особенностью</strong> функционального программирования, определяющей как преимущества, так и недостатки данной парадигмы, \r\n            является то, что в ней <strong>реализуется модель вычислений без состояний.</strong> Если императивная программа на любом этапе исполнения имеет \r\n            состояние, то есть совокупность значений всех переменных, и производит побочные эффекты, то <strong>чисто функциональная программа ни целиком,\r\n             ни частями состояния не имеет и побочных эффектов не производит.</strong> То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций. Непосредственным следствием становится то, что чисто функциональная программа не может изменять уже имеющиеся у неё данные, а может лишь порождать новые путём копирования и/или расширения старых. Следствием того же является отказ от циклов в пользу рекурсии.\r\n            </p>\r\n\r\n            <h3>Сильные стороны</h3>\r\n                \r\n                <ul className='row list_style'>\r\n                <li>\r\n                <p><strong>Повышение надёжности кода</strong></p>\r\n                Привлекательная сторона вычислений без состояний — <strong>повышение надёжности кода за счёт чёткой структуризации и \r\n                отсутствия необходимости отслеживания побочных эффектов. Любая функция работает только с локальными данными и \r\n                работает с ними всегда одинаково, независимо от того, где, как и при каких обстоятельствах она вызывается. \r\n                Невозможность мутации данных при пользовании ими в разных местах программы исключает появление \r\n                труднообнаруживаемых ошибок </strong>(таких, например, как случайное присваивание неверного значения глобальной \r\n                переменной в императивной программе).\r\n                <p></p>\r\n                </li>\r\n\r\n                <li><p><strong>Удобство организации модульного тестирования</strong></p>\r\n                Поскольку функция в функциональном программировании не может порождать побочные эффекты, менять объекты нельзя как внутри области \r\n                видимости, так и снаружи (в отличие от императивных программ, где одна функция может установить какую-нибудь внешнюю переменную, \r\n                считываемую второй функцией). Единственным эффектом от вычисления функции является возвращаемый ей результат, \r\n                и единственный фактор, оказывающий влияние на результат — это значения аргументов.\r\n                    <div></div>\r\n                    <strong>Таким образом, имеется возможность протестировать каждую функцию в программе, просто вычислив её от различных наборов \r\n                значений аргументов. При этом можно не беспокоиться ни о вызове функций в правильном порядке, ни о правильном формировании \r\n                внешнего состояния. Если любая функция в программе проходит модульные тесты, то можно быть уверенным в качестве всей программы.\r\n                </strong> \r\n                В императивных программах проверка возвращаемого значения функции недостаточна: функция может модифицировать внешнее состояние,\r\n                 которое тоже нужно проверять, чего не нужно делать в функциональных программах.\r\n                 <p></p>\r\n                 </li>\r\n\r\n                <li><p><strong>Возможности оптимизации при компиляции</strong></p>\r\n                Традиционно упоминаемой положительной особенностью функционального программирования является то, что оно позволяет описывать\r\n                программу в так называемом «декларативном» виде, когда жесткая последовательность выполнения многих операций, необходимых для\r\n                 вычисления результата, в явном виде не задаётся, а формируется автоматически в процессе вычисления функций. Это обстоятельство,\r\n                  а также отсутствие состояний даёт возможность применять к функциональным программам достаточно сложные методы автоматической \r\n                  оптимизации.\r\n                  <p></p>\r\n                  </li>\r\n\r\n                <li><p><strong>Возможности параллелизма</strong></p>\r\n                Ещё одним преимуществом функциональных программ является то, что они предоставляют широчайшие возможности для автоматического \r\n                распараллеливания вычислений. <strong>Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда допустимо \r\n                параллельное вычисление двух различных параметров — порядок их вычисления не может оказать влияния на результат вызова.</strong>\r\n                <p></p>\r\n                </li>\r\n                </ul> \r\n\r\n                <h3>Недостатки</h3>\r\n                <p></p>\r\n                Недостатки функционального программирования вытекают из тех же самых его особенностей. Отсутствие присваиваний и замена \r\n                их на порождение новых данных приводят к необходимости постоянного выделения и автоматического освобождения памяти, поэтому \r\n                в системе исполнения функциональной программы обязательным компонентом становится высокоэффективный сборщик мусора.\r\n                 Нестрогая модель вычислений приводит к непредсказуемому порядку вызова функций, что создаёт проблемы при вводе-выводе, \r\n                 где порядок выполнения операций важен. Кроме того, очевидно, функции ввода в своём естественном виде \r\n                 (например, getchar из стандартной библиотеки языка C) не являются чистыми, поскольку способны возвращать различные\r\n                  значения для одних и тех же аргументов, и для устранения этого требуются определённые ухищрения.\r\n\r\n                Для преодоления недостатков функциональных программ уже первые языки функционального программирования включали не\r\n                 только чисто функциональные средства, но и механизмы императивного программирования (присваивание, цикл, «неявный PROGN»\r\n                  были уже в Лиспе). Использование таких средств позволяет решить некоторые практические проблемы, но означает отход от идей \r\n                  (и преимуществ) функционального программирования и написание императивных программ на функциональных языках. \r\n                  В чистых функциональных языках эти проблемы решаются другими средствами, например, в языке Haskell \r\n                  ввод-вывод реализован при помощи монад — нетривиальной концепции, позаимствованной из теории категорий.         \r\n    </div>\r\n    <p></p>\r\n    <div>\r\n    <a href='https://habr.com/ru/post/142351/'> Более развернуто о ФП можно почитать тут</a>  \r\n    </div>\r\n    <h3>Мякотка</h3>\r\n    <p>Ок,это все были общие положения относитльно ФП. Но что может показаться интерсным нам, как js-разработчикам?</p>\r\n    <div>Смотрим <ScrollTo text='видео' top={150} left={0} /> тов. Шемсединова и читаем <a href='https://tproger.ru/translations/functional-js-1/'>статью эту </a>\r\n    и <a href ='https://tproger.ru/translations/functional-js-2/'>и эту </a>\r\n    чтобы разобраться что такое функторы\r\n    и монады. Какие они бывают и какие задачи решают. </div>\r\n    <h3>Функторы</h3>\r\n    <p>Если просто, функторы- это некая сущность(в js это можно реализовать через классы\\протитипы\\ и замыкания) которая реализует метод map.\r\n        <div>Вспоминаем Array.map и пониамем о чем идет речь - то, что возвращает НОВЫЙ МОДИФИЦИРОВАННЫЙ объект</div>\r\n        <div><img src={require('./assets/functor.png')}/></div>\r\n        <div>Обратим внимание на слово НОВЫЙ. Мы не мутируем, не изменяем текущий объект. Это одна из основ ФП, как ясно из теории.</div>\r\n        <div>Наш map действует точно также, как и привычный в Array.prototype - он принимает некотрую функцию и согласно ее алгоритму возвращает объект.    \r\n        Так что многие следовают функциональному стилю, даже не задумываясь об этом.\r\n        Также тут есть страховка, в виде проверки. Если чего-то не хватает - вернем Null.\r\n        </div>\r\n    <h3>Монады</h3>\r\n    <p>\r\n    Монады — это подтип функторов, так как у них есть метод map, но они также реализуют другие методы, например, ap, of, chain.\r\n    <div><img src={require('./assets/monad.png')}/></div>\r\n    </p>\r\n    </p>\r\n    <h3>Выводы</h3>\r\n    <div>JS- мультипарадигменный язык, никто не мешает нам использовать лучшие практики с раличных парадигм и совмещать их. Никто не заставляет писать \r\n        чисто в одной парадигме.(да и писать чисто на ФП === невозможно, так как много токостей, допустим отрицание переменных)\r\n    </div>\r\n    <div>Используя элмененты ФП мы можем избегать ошибок, свзанных с мутацией. Мы лучше контрлируем происходящее. Мы можем упрощать юнит-тестирование. Создавая переиспользуемые\r\n         функции, мы делаем код лаконичней и красивее. Следуем принципу dry. Каррирование позволяет нам удобнее выстраивать систему\r\n          взаимодействия(основа паттерна декоратор в js).Ну а рекурсия обычно короче и красивей.</div>\r\n</div>\r\nexport default Functional","import React from 'react';\nimport './App.css';\nimport {HashRouter as Router, Route, Switch} from 'react-router-dom';\nimport WelcomePage from './components/welcomepage';\nimport Header from './components/header';\nimport OOP from './units/paradigmas/oop';\nimport Solid from './units/principles/solid';\nimport Kiss from './units/principles/kiss';\nimport Functional from './units/paradigmas/functional';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nfunction App() {\n  return (\n    <Router>\n        <Switch>\n            <div className='mx-3'>\n                <Header/>\n                <Route path='/' component={WelcomePage} exact />\n                <Route path=\"/oop\" render={()=><OOP/>} />\n                <Route path=\"/func\" render={()=><Functional/>} />\n                <Route path=\"/solid\" render={()=><Solid/>} />\n                <Route path=\"/kiss\" render={()=><Kiss/>} />\n            </div>\n        </Switch>\n    </Router>\n);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}