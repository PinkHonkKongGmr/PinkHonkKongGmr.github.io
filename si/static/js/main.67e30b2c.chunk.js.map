{"version":3,"sources":["components/welcomepage/index.js","components/welcomepage/welcomepage.js","components/unit/index.js","components/unit/unit.js","components/header/index.js","components/header/header.js","units/paradigmas/oop/index.js","units/paradigmas/oop/oop.js","helperComponent/scrollTo/index.js","helperComponent/scrollTo/sctrollto.js","units/principles/solid/index.js","units/principles/solid/solid.js","units/paradigmas/functional/index.js","units/paradigmas/functional/functional.js","App.js","serviceWorker.js","index.js"],"names":["WelcomePage","Unit","props","slide","condtition","state","toShowlist","setState","listClass","this","lists","topics","map","topic","ind","className","key","to","href","text","onClick","title","React","PureComponent","Header","OOP","Scrollto","scrollto","window","scrollTo","top","left","behavior","Component","Solid","id","width","height","src","frameborder","allow","allowfullscreen","Functional","App","path","component","exact","render","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","StrictMode","document","getElementById","URL","process","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.67e30b2c.chunk.js","sourcesContent":["import WelcomePage from './welcomepage'\r\nexport default WelcomePage","import React from 'react'\r\n\r\nconst WelcomePage = () =><div>Ни день без js!</div>\r\n\r\nexport default WelcomePage","import Unit from './unit'\r\nexport default Unit","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\n\r\n\r\nclass Unit extends React.PureComponent  {\r\n   constructor(props){\r\n       super(props)\r\n       this.state={\r\n           toShowlist:false\r\n       }\r\n   }\r\n\r\n\r\n   slide = () =>{\r\n    let condtition = this.state.toShowlist ? false : true\r\n    this.setState({toShowlist: condtition})\r\n   }\r\n\r\n   render(){\r\n     let listClass = this.state.toShowlist ? 'show' :'hide'\r\n     let lists = this.props.topics.map((topic, ind) =>   <li className = {listClass} key={ind}>\r\n                                     <Link to= {topic.href}>{topic.text}</Link>\r\n                                </li>)\r\n     return    <div>\r\n                <h2 onClick={this.slide} className = 'clickable__title'>{this.props.title}</h2>\r\n                {lists}\r\n            </div>\r\n        }\r\n   }\r\n\r\n\r\n\r\nexport default Unit","import Header from './header'\r\nexport default Header","import React from 'react';\r\nimport './header.css'\r\nimport Unit from '../unit'\r\n\r\n\r\n\r\nconst Header = () => {\r\n  return ( \r\n\r\n  <div className=\"header\">\r\n      <h1>\r\n          Навигация\r\n      </h1>\r\n      <ul className=\"\">\r\n         <Unit title = 'Парадигмы' topics = {[{href:'/oop',text:'ООП'},{href:'/func',text:'Функциональная парадигма'}]}/>\r\n         <Unit title = 'Принципы' topics = {[{href:'/solid',text:'SOLID'}]}/>\r\n      </ul>\r\n  </div>\r\n\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import OOP from './oop'\r\nexport default OOP","import React from 'react'\r\nimport {Link} from 'react-router-dom';\r\n\r\nconst OOP = () => <div>\r\n    <h2>Итак, ооп!</h2>\r\n    <p>Начнем с сухих определений. Далеко лазить не будем. Откроем википедию и посмотрим что она скажет нам об ООП</p>\r\n    <p><strong>Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности\r\n     объектов,\r\n     каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</strong></p>\r\n     <p>Спасибо, википедия, из этого мы можем сделать вывод что ООП оперирует обьектами, каждый объект несет ряд свойств и характеристик, по которым их \r\n        можно объеденить. Тоесть у кажого объекта есть свой класс. Мы можем создавать новые объекты, наделяя их определенным классом. Это значит\r\n        что новый объект получит(унаследует) всю мощь объекта - прородителя</p>\r\n    <p>Хорошо. Но мы, как умные ребята и правильные посоны изучим и другие источники</p>\r\n    <p>\r\n    <strong>\r\n    Центральными в ООП являются понятия класса и объекта. Образно говоря, ООП заключается не столько в использовании классов и объектов в программе, сколько в замене принципа программирования \"от функции к функции\" принципом программирования \"от класса к классу\".\r\n    Технология ООП прежде всего накладывает ограничения на способы представления данных в программе. Любая программа отражает в них состояние физических предметов либо абстрактных понятий (назовем их объектами программирования), для работы с которыми она предназначена. В традиционной технологии варианты представления данных могут быть разными. В худшем случае программист может \"равномерно размазать\" данные о некотором объекте программирования по всей программе. В противоположность этому все данные об объекте программирования и его связях с другими объектами можно объединить в одну структурированную переменную. В первом приближении ее можно назвать объектом. Кроме того, с объектом связывается набор действий, иначе называемых методами. С точки зрения языка программирования это функции, получающие в качестве обязательного параметра указатель на объект. Технология ООП запрещает работать с объектом иначе, чем через методы, то есть внутренняя структура объекта скрыта от внешнего пользователя. Описание множества однотипных объектов называется классом.\r\n    Объект - структурированная переменная, содержащая всю информацию о некотором физическом предмете или реализуемом в программе понятии.\r\n    Класс - описание множества таких объектов и выполняемых над ними действий.\r\n    </strong>\r\n    </p>\r\n\r\n    <p>Очень хорошо, так мы приходим к пониманию, что ООП это не столько про классы, сколько про СПОСОБ ОРГАНИЗАЦИИ КОДА</p>\r\n    <p>Чтобы разобраться какие преймущества дает этот подход, рассмотрим основные ПРИНЦИПЫ ООП. Ты наверняка о них слышал </p>\r\n    <p>По классике выделяют 3 принципа. Но в некоторых источниках число доходит до 8. Обозначим четыре. Добавим абстрагирование</p>\r\n    <p></p>\r\n    <p>\r\n  \r\n    <p>\r\n    <div>\r\n    Начну с абстрагирования. Это очень важное в ООП понятие. Так как именно оно лежит в основе возможности расширения приложений. \r\n        В основе классов тоже лежит некая астракция(интерфейс), которая реализуется в наследовании\r\n    </div>\r\n    <strong>Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения не значимые.Соответственно, абстракция — это набор всех таких характеристик. </strong>\r\n    </p>\r\n    <p>\r\n     <div>Наследование. Тут более-менее все должно быть ясно, хотя бы на интуитивном уровне.</div> \r\n    <strong>\r\n    Наследование — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью\r\n     заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, \r\n     родительским или суперклассом. Новый класс — потомком, наследником или производным классом\r\n     </strong>\r\n     </p>\r\n     <div>Ну и классический пример с машинками. </div>\r\n     <div>У нас есть класс - автомобиль.</div>\r\n     <div>И дочерний класс - хэтчбеки.</div>\r\n    Хэтчбэки наследуют у автомобиля 4 колеса, выхлопную трубу, способность ездить и прочие базовые характеристики и умения автомобиля. При этом у него будут свои характеристики, свойственные именно хэтчбеку.\r\n    </p>\r\n    <p>\r\n    С инкапсуляцией есть некоторые тонкости. Часто выделяют СОКРЫТИЕ ДАННЫХ как основной смысл инкапсуляции, однако же сокрытие есть важный побочный \r\n    продукт инкапсуляции. Суть в том, что\r\n    <div><strong>\r\n    Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе\r\n    </strong></div>\r\n    <div>\r\n        или\r\n        <div>\r\n            <strong>\r\n            В информатике размещение в одном компоненте данных и методов, которые с ними работают. Также может означать скрытие внутренней реализации от других компонентов. \r\n            Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения и изменения её значения\r\n            </strong>\r\n        </div>\r\n    </div>\r\n    <div>Инкапсуляция повзоляет выстраивать архитектуру. Разбивать на отдельные модули. Предоставляет возможность удобства в пользовании компонентами.\r\n        Обеспечивает безопасность сокрытием.\r\n    </div>\r\n    </p>\r\n    <p>И наконец, его величество полиорфизм. Страшный дядька, которого в некоторых источниках выделяют как столп ООП, называя принципы выше лишь его подспорьем.\r\n    <div>Может, так оно и есть. Ведь именно полиморфизм задает ноту универсальности интерфейсов. Позволяет выстраивать гибкую и расширяемую архитектуру.\r\n        </div> \r\n        <div>Ведь основной смысл ООП в том, что благодаря ему мы можем превратить скромный туду-лист в сложный многофункциональный органайзер по типу jira. При этом не сойдя с ума от того, что на каком-то этапе\r\n            новый функционал добавлять стало невроятно сложно, баги сыпятся как из рога страданий,отловить их не может даже Чак Норрис, а запутаться в коде могут не только лишь все. </div>\r\n            <div>Определений, как и типов полиморфизма много. Пока не буду на этом заострять внимание. Приведу наиболее лакончиные</div>\r\n            <div>\r\n            <strong>Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</strong>\r\n            </div>\r\n            <div><strong>Полиморфизм — способность функции обрабатывать данные разных типов.</strong></div>\r\n            <div><strong>Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.</strong></div>\r\n </p>\r\n\r\n<p></p>\r\n<p>Подведем итог.</p>\r\n<p>Смысл ООП - выстраивании гибкой, расширяемой и надежной архитектуры. \r\n    Но основе ООП строится <Link to='/solid'>solid</Link>. Которые повсеместно используются в создании приложений.</p>\r\n</div>\r\n\r\nexport default OOP","import Scrollto from './sctrollto'\r\nexport default Scrollto","import  React from 'react'\r\nimport './scrollto.scss'\r\n\r\nclass Scrollto extends React.Component{\r\nconstructor(props){\r\n    super(props)\r\n    }\r\n\r\n    scrollto = () =>{\r\n        window.scrollTo({top:this.props.top,left:this.props.left, behavior: \"smooth\"})\r\n    }\r\n\r\n\r\n    render(){\r\n    return <span className='scroller' onClick ={this.scrollto}>{this.props.text}</span>\r\n    }\r\n}\r\n\r\nexport default Scrollto","import Solid from './solid'\r\nexport default Solid","import React from 'react'\r\nimport ScrollTo from '../../../helperComponent/scrollTo'\r\nimport {Link} from 'react-router-dom';\r\n\r\nconst Solid = () =><div>\r\n    <h2>Итак, solid!</h2>\r\n    <h3>Хорошее видево от тов. Минина</h3>\r\n    <iframe id ={'mininsolid'} width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/xq13wiqvcTc\" \r\n    frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\r\n     allowfullscreen></iframe>\r\n     <p></p>\r\n     <p></p>\r\n     <h3>Ну а начнем, пожалуй, по традиций с определений и вики</h3> \r\n     <p><strong>SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion)\r\n     в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers)\r\n      для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов \r\n      объектно-ориентированного программирования и проектирования.</strong></p>\r\n      <h3>Назначение</h3>\r\n      <p>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать \r\n          и расширять в течение долгого времени. Принципы SOLID — это руководства, которые также могут применяться во время работы над \r\n        существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».\r\n\r\nСтратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.</p>\r\n\r\n<h3>Сами принципы КРАТКО</h3>\r\n\r\n<table>\r\n    <tr>\r\n        <th>Инициал</th>\r\n        <th>Название и суть</th>\r\n    </tr>\r\n  <tr>\r\n    <td>S</td>\r\n    <td>Принцип единственной ответственности (The Single Responsibility Principle)\r\n    Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. \r\n    Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.</td>\r\n  </tr>\r\n  <tr>\r\n    <td>O</td>\r\n    <td>\r\n    Принцип открытости/закрытости (The Open Closed Principle)\r\n    «программные сущности … должны быть открыты для расширения, но закрыты для модификации.»\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>L</td>\r\n    <td>\r\n    Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)\r\n    «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»\r\n    Наследующий класс должен дополнять, а не изменять базовый.\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>I</td>\r\n    <td>\r\n    Принцип разделения интерфейса (The Interface Segregation Principle)\r\n    «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»\r\n    </td>\r\n  </tr>\r\n  <tr>\r\n    <td>D</td>\r\n    <td>\r\n    Принцип инверсии зависимостей (The Dependency Inversion Principle)\r\n    Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\r\n    Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\r\n    </td>\r\n  </tr>\r\n</table>\r\n<h3>Звучит несомненно замечательно. Но что со всем эти делать?(кроме как выпендриваться на собесах)</h3>\r\n<p>Тов. Минин, я вызываю тебя! Далее материал будет на основе <ScrollTo text='урока' top={20} left={0} /> ибо хорошо разложено для js </p>\r\n<p><strong>The Single Responsibility Principle</strong></p>\r\n<p>Суть такова: если надо расширить класс новым функционалом. Добавить новое поведение.\r\n  Лучше вынести это поведение в отдельный класс.</p> \r\n  <p>И пример от маэстро</p>\r\n  <p>Ниже описывается класс news. В нем инкапсулированы только те сущности, котроые отвечают непосредственно за новость: контент и возможность\r\n       обновления. С этой новостью мы можем делать что хотим: отобразить на странице в html, передать в json, xml и тд. И можно в классе news задать \r\n       методы обработки в нужный формат. Можно, да. Тогда мы будем нарушать наш принцип.\r\n       <strong>Почему это не хорошо? Почему следует вынести обработчик в одельный класс?</strong></p>\r\n       <p>\r\n          <strong> \r\n       Во первых мы не перегружаем сам класс. Он остается лаконичным и понятным. Во вторых мы создаем универсальный класс -обрабочтик, \r\n       которым могут пользоваться другие классы, помимо news. </strong>\r\n       <div> ->В примере обработчик конренто для news и принимает экземпляр news. Но чисто теоретически можно эктраполировать на что угодно.</div>\r\n       </p>\r\n        <a href='https://github.com/vladilenm/SOLID_javascript/blob/master/1_S.js'>Ссылка на пример</a>\r\n        <p></p>\r\n        <p>Мнение вики</p>\r\n        <p>\r\n       <strong>Возникает вопрос, когда стоит использовать этот принцип? Всё же принцип — это не закон и SRP стоит применять в\r\n        зависимости от того, как изменяется приложение:</strong></p>\r\n\r\n<div> -если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, \r\n    отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.</div>\r\n<div> -если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, \r\n    то этот принцип можно не применять.</div>\r\n    <p></p>\r\n<p>\r\nСлепое следование принципу единственной ответственности приводит к избыточной сложности приложения,\r\n его поддержки и тестирования. SRP стоит применять только тогда, когда это оправдано.\r\n  Принцип SRP можно применить только в том случае, когда:</p>\r\n\r\n<div> -объекту класса становится позволительно слишком много;</div>\r\n<div> -доменная логика концентрируется только в одном классе;</div>\r\n<div> -любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;</div>\r\n<div> -приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья\r\n     сторона;</div>\r\n<div> -невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.</div>\r\n\r\n<div>\r\n    <p></p>\r\n<strong>Объединение ответственностей является общепринятой практикой и в этом нет ничего плохого,\r\n до тех пор пока это легко обслуживать. Следование принципу единственной ответственности зависит от функций \r\n программного продукта и является труднейшим при проектировании приложений.</strong></div>\r\n <p></p>\r\n  <p>Прочитав все и ознакомившись с примером, ты дорогой читатель мог и запутаться. Когда стоит, а когда не стоит применять этот принцип в js.\r\n      Понимание придет с опытом. На мой взляд не стоит пихать этот принцип всюду и дробить все подряд. Как критерием может послужить момент \r\n      из <Link to='/oop'>ооп</Link>. А именно абстрагирование. Насколько поведение можно назвать значимым неосредственно \r\n      для конкретного класса. И можно ли это поведение \r\n      абстрагировать от класса и применить к другому классу. Если нет\\да - то тогда можно применить принцип. (Мое мнение)\r\n  </p>\r\n  <p></p>\r\n  <p><strong>The Open Closed Principle</strong></p>  \r\n  <p>Классы должны быть ОТКРЫТЫ для РАСШИРЕНИЯ и ЗАКРЫТЫ для МОДИФИКАЦИИ\r\n  <div><strong>Смысл принципа в том, что мы выстраиваеи код таким образом, что если нам протребуется добавить какие-либо возможности и новый функционал \r\n      то мы НЕ ПЕРЕПИСЫВАЕМ старый код.</strong>\r\n      <p>\r\n          В примере у нас есть фигуры и класс, который считает площади. Этот класс мог бесконечно модифицироваться ифами с появлением новых классов фигур.\r\n          Это больно. Поэтому мы не переписываем логику класса площадей, а вводим базовый класс для фигур, который повзоляет возвращать площадь. А класс площадей\r\n          универсально их принимает и выдает результат.\r\n          <strong>Каждая новая фигура требует РАСШИРЕНИЕ числa дочерних классов фигуры, а не МОДИФИЦИКАЦИИ класса площадей.</strong>\r\n          <a href='https://github.com/vladilenm/SOLID_javascript/blob/master/2_O.js'>Пример</a>\r\n      </p>\r\n        <p></p>\r\n        <p><strong>The Liskov Substitution Principle</strong></p> \r\n        <p>\r\n            <div>Вики подкидывает нам размышления несколько философского толка:</div>\r\n        Принцип Барбары Лисков заставляет задуматься о том, что такое «декларация типа» в терминах \r\n        объектно-ориентированного языка программирования, который мы используем. Достаточно ли нам описать интерфейс объекта\r\n         с помощью обычного абстрактного класса со списком методов, типами параметров и возвращаемого значения? Каким образом мы можем \r\n         декларировать требования к значениям параметров метода и свойства, которыми будет обладать возвращаемое значение? Как нам описать \r\n         исключения, которые может сгенерировать метод во время выполнения? Как нам описать изменение состояния объекта на разных этапах его\r\n          жизненного цикла?\r\n        Задавая себе эти вопросы и находя ответы, можно спроектировать систему, которая действительно будет удовлетворять \r\n        принципу подстановки \r\n    Барбары Лисков.\r\n        </p>\r\n        <p><strong>Роберт С. Мартин определил этот принцип так:\r\n            Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.</strong></p>\r\n        <p><div>Cуть в том, что функция должна уметь работать как с базовым типом, так с его потомками одинаково. \r\n            </div>Тов. Минин привел пример с классом Person\r\n             от которого\r\n            наследуются сотрудники двух разных компаний. Одни имеют доступ к секретной двери. Другие нет. \r\n            Так вот функция, которая проверяет на доступ выбрасывае ошибку\r\n            на тех ребятах, которые из другой компании. Хотя принимает она во всех случаях person. \r\n            Ведь именно класс person содержит инфу о ключе.\r\n            Это и нарушает принцип Liskov substitution. Для решения проблемы мы вводим новый уровень\r\n            абстракции. Person получает двух наследников. Собтсвенно члены компании и гости. И уже на этом уровне,\r\n             в этих двух классах мы и определяем ключи.\r\n            А секретная дверь будет работать уже с ними.\r\n            <div>Во втором примере показана работа с компонентами. Когда компоненты разных типов наследовались от класса components который содержал render\r\n                 метод.\r\n                Проблема возникла, когда появился hoc, тоесть компонент который \"отключает\" рендер, так как мы знаем что hocи не имеют редер\\а \r\n                если не знаем читаем\\. \r\n                Соответсвенно на функции rendercomponent, которая использовала render от components выбрасывается ошибка. Алгоритм аналогичный - вводим новый уровень абстракции и переносим render туда\r\n                где он нужен. RenderComponent будет работать только с этим классом.\r\n\r\n            </div>\r\n            <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/3_L.js'>Примеры</a>\r\n        </p>\r\n        <p><strong>The Interface Segregation Principle</strong></p> \r\n        <div>Вики</div>\r\n        <p><strong>\r\n        Роберт С. Мартин определил этот принцип так:\r\n\r\nПрограммные сущности не должны зависеть от методов, которые они не используют.\r\nПринцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические,\r\n чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода \r\n интерфейса не должны меняться программные сущности, которые этот метод не используют.\r\n            </strong>\r\n            <div>Следование этому принципу помогает системе оставаться гибкой при внесении изменений в логику работы и пригодной для рефакторинга.</div>\r\n            </p>\r\n            <p>Суть в том, что если наследник не использует метод, который он получил от родителя, использует не корректно, \r\n                значит мы сделали что-то не так</p>\r\n                <div>Тов. Минин привел очень наглядный пример с животными. Базовый класс Animal содержал в себе методы- спосбности животных.\r\n                    Но наследник собака не умеет летать. А такой метод есть в базоом классе. Пришлось \"обнулять\" его.\r\n                    Вместо этого автор предложил использовал композицию, благодаря которой можно добавлять только нужные умения.\r\n                    <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/4_I.js'>Пример</a>\r\n                </div>\r\n  </div>\r\n  </p>\r\n  <p><strong>The Dependency Inversion Principle</strong></p> \r\n  <p>\r\n  <strong>\r\n  Формулировка:\r\n  <div>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</div>\r\n  <div>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</div>\r\n  </strong>\r\n  </p>\r\n  <p>Тов. Минин привел живой пример, где база данных получала данные из разных источников. Первоначально это был условный фетч. \r\n      И класс ДБ первоначально вызывал экземпляр фетча. Но потом вяснилось что данные подтягиваются с локалстараджа, поэтому ДБ пришлось переписать.\r\n      <div>На лицо зависимость абстракции от деталей</div>\r\n      Устраняем это введением новых абстракций, отвечающих за конкретный тип, с которыми и будет работать ДБ.\r\n      <a href ='https://github.com/vladilenm/SOLID_javascript/blob/master/5_D.js'>Пример</a>\r\n      </p>\r\n</div>\r\n\r\nexport default Solid","import Functional from './functional'\r\nexport default Functional","import React from 'react'\r\n\r\nconst Functional = () => <div>\r\n    <h1>Итак, ФП!</h1>\r\n</div>\r\n\r\nexport default Functional","import React from 'react';\nimport './App.css';\nimport {HashRouter as Router, Route, Switch} from 'react-router-dom';\nimport WelcomePage from './components/welcomepage';\nimport Header from './components/header';\nimport OOP from './units/paradigmas/oop';\nimport Solid from './units/principles/solid';\nimport Functional from './units/paradigmas/functional';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nfunction App() {\n  return (\n    <Router>\n        <Switch>\n            <div className='mx-3'>\n                <Header/>\n                <Route path='/' component={WelcomePage} exact />\n                <Route path=\"/oop\" render={()=><OOP/>} />\n                <Route path=\"/func\" render={()=><Functional/>} />\n                <Route path=\"/solid\" render={()=><Solid/>} />\n            </div>\n        </Switch>\n    </Router>\n);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}