{"version":3,"sources":["components/welcomepage/index.js","components/welcomepage/welcomepage.js","components/unit/index.js","components/unit/unit.js","components/header/index.js","components/header/header.js","units/paradigmas/oop/index.js","units/paradigmas/oop/oop.js","units/principles/solid/index.js","units/principles/solid/solid.js","units/paradigmas/functional/index.js","units/paradigmas/functional/functional.js","App.js","serviceWorker.js","index.js"],"names":["WelcomePage","Unit","props","slide","condtition","state","toShowlist","setState","listClass","this","lists","topics","map","topic","ind","className","key","to","href","text","onClick","title","React","PureComponent","Header","OOP","Solid","Functional","App","path","component","exact","render","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","StrictMode","document","getElementById","URL","process","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.8366f3f3.chunk.js","sourcesContent":["import WelcomePage from './welcomepage'\r\nexport default WelcomePage","import React from 'react'\r\n\r\nconst WelcomePage = () =><div>Ни день без js!</div>\r\n\r\nexport default WelcomePage","import Unit from './unit'\r\nexport default Unit","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\n\r\nclass Unit extends React.PureComponent  {\r\n   constructor(props){\r\n       super(props)\r\n       this.state={\r\n           toShowlist:false\r\n       }\r\n   }\r\n\r\n\r\n   slide = () =>{\r\n    let condtition = this.state.toShowlist ? false : true\r\n    this.setState({toShowlist: condtition})\r\n   }\r\n\r\n   render(){\r\n     let listClass = this.state.toShowlist ? 'show' :'hide'\r\n     let lists = this.props.topics.map((topic, ind) =>   <li className = {listClass} key={ind}>\r\n                                     <Link to= {topic.href}>{topic.text}</Link>\r\n                                </li>)\r\n     return    <div>\r\n                <h2 onClick={this.slide} className = 'clickable__title'>{this.props.title}</h2>\r\n                {lists}\r\n            </div>\r\n        }\r\n   }\r\n\r\n\r\n\r\nexport default Unit","import Header from './header'\r\nexport default Header","import React from 'react';\r\nimport './header.css'\r\nimport Unit from '../unit'\r\n\r\n\r\n\r\nconst Header = () => {\r\n  return ( \r\n\r\n  <div className=\"header\">\r\n      <h1>\r\n          Навигация\r\n      </h1>\r\n      <ul className=\"\">\r\n         <Unit title = 'Парадигмы' topics = {[{href:'/oop',text:'ООП'},{href:'/func',text:'Функциональная парадигма'}]}/>\r\n         <Unit title = 'Принципы' topics = {[{href:'/solid',text:'SOLID'}]}/>\r\n      </ul>\r\n  </div>\r\n\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import OOP from './oop'\r\nexport default OOP","import React from 'react'\r\nimport {Link} from 'react-router-dom';\r\n\r\nconst OOP = () => <div>\r\n    <h2>Итак, ооп!</h2>\r\n    <p>Начнем с сухих определений. Далеко лазить не будем. Откроем википедию и посмотрим что она скажет нам об ООП</p>\r\n    <p><strong>Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности\r\n     объектов,\r\n     каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</strong></p>\r\n     <p>Спасибо, википедия, из этого мы можем сделать вывод что ООП оперирует обьектами, каждый объект несет ряд свойств и характеристик, по которым их \r\n        можно объеденить. Тоесть у кажого объекта есть свой класс. Мы можем создавать новые объекты, наделяя их определенным классом. Это значит\r\n        что новый объект получит(унаследует) всю мощь объекта - прородителя</p>\r\n    <p>Хорошо. Но мы, как умные ребята и правильные посоны изучим и другие источники</p>\r\n    <p>\r\n    <strong>\r\n    Центральными в ООП являются понятия класса и объекта. Образно говоря, ООП заключается не столько в использовании классов и объектов в программе, сколько в замене принципа программирования \"от функции к функции\" принципом программирования \"от класса к классу\".\r\n    Технология ООП прежде всего накладывает ограничения на способы представления данных в программе. Любая программа отражает в них состояние физических предметов либо абстрактных понятий (назовем их объектами программирования), для работы с которыми она предназначена. В традиционной технологии варианты представления данных могут быть разными. В худшем случае программист может \"равномерно размазать\" данные о некотором объекте программирования по всей программе. В противоположность этому все данные об объекте программирования и его связях с другими объектами можно объединить в одну структурированную переменную. В первом приближении ее можно назвать объектом. Кроме того, с объектом связывается набор действий, иначе называемых методами. С точки зрения языка программирования это функции, получающие в качестве обязательного параметра указатель на объект. Технология ООП запрещает работать с объектом иначе, чем через методы, то есть внутренняя структура объекта скрыта от внешнего пользователя. Описание множества однотипных объектов называется классом.\r\n    Объект - структурированная переменная, содержащая всю информацию о некотором физическом предмете или реализуемом в программе понятии.\r\n    Класс - описание множества таких объектов и выполняемых над ними действий.\r\n    </strong>\r\n    </p>\r\n\r\n    <p>Очень хорошо, так мы приходим к пониманию, что ООП это не столько про классы, сколько про СПОСОБ ОРГАНИЗАЦИИ КОДА</p>\r\n    <p>Чтобы разобраться какие преймущества дает этот подход, рассмотрим основные ПРИНЦИПЫ ООП. Ты наверняка о них слышал </p>\r\n    <p>По классике выделяют 3 принципа. Но в некоторых источниках число доходит до 8. Обозначим четыре. Добавим абстрагирование</p>\r\n    <p></p>\r\n    <p>\r\n  \r\n    <p>\r\n    <div>\r\n    Начну с абстрагирования. Это очень важное в ООП понятие. Так как именно оно лежит в основе возможности расширения приложений. \r\n        В основе классов тоже лежит некая астракция(интерфейс), которая реализуется в наследовании\r\n    </div>\r\n    <strong>Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения не значимые.Соответственно, абстракция — это набор всех таких характеристик. </strong>\r\n    </p>\r\n    <p>\r\n     <div>Наследование. Тут более-менее все должно быть ясно, хотя бы на интуитивном уровне.</div> \r\n    <strong>\r\n    Наследование — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью\r\n     заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, \r\n     родительским или суперклассом. Новый класс — потомком, наследником или производным классом\r\n     </strong>\r\n     </p>\r\n     <div>Ну и классический пример с машинками. </div>\r\n     <div>У нас есть класс - автомобиль.</div>\r\n     <div>И дочерний класс - хэтчбеки.</div>\r\n    Хэтчбэки наследуют у автомобиля 4 колеса, выхлопную трубу, способность ездить и прочие базовые характеристики и умения автомобиля. При этом у него будут свои характеристики, свойственные именно хэтчбеку.\r\n    </p>\r\n    <p>\r\n    С инкапсуляцией есть некоторые тонкости. Часто выделяют СОКРЫТИЕ ДАННЫХ как основной смысл инкапсуляции, однако же сокрытие есть важный побочный \r\n    продукт инкапсуляции. Суть в том, что\r\n    <div><strong>\r\n    Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе\r\n    </strong></div>\r\n    <div>\r\n        или\r\n        <div>\r\n            <strong>\r\n            В информатике размещение в одном компоненте данных и методов, которые с ними работают. Также может означать скрытие внутренней реализации от других компонентов. \r\n            Например, доступ к скрытой переменной может предоставляться не напрямую, а с помощью методов для чтения и изменения её значения\r\n            </strong>\r\n        </div>\r\n    </div>\r\n    <div>Инкапсуляция повзоляет выстраивать архитектуру. Разбивать на отдельные модули. Предоставляет возможность удобства в пользовании компонентами.\r\n        Обеспечивает безопасность сокрытием.\r\n    </div>\r\n    </p>\r\n    <p>И наконец, его величество полиорфизм. Страшный дядька, которого в некоторых источниках выделяют как столп ООП, называя принципы выше лишь его подспорьем.\r\n    <div>Может, так оно и есть. Ведь именно полиморфизм задает ноту универсальности интерфейсов. Позволяет выстраивать гибкую и расширяемую архитектуру.\r\n        </div> \r\n        <div>Ведь основной смысл ООП в том, что благодаря ему мы можем превратить скромный туду-лист в сложный многофункциональный органайзер по типу jira. При этом не сойдя с ума от того, что на каком-то этапе\r\n            новый функционал добавлять стало невроятно сложно, баги сыпятся как из рога страданий,отловить их не может даже Чак Норрис, а запутаться в коде могут не только лишь все. </div>\r\n            <div>Определений, как и типов полиморфизма много. Пока не буду на этом заострять внимание. Приведу наиболее лакончиные</div>\r\n            <div>\r\n            <strong>Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</strong>\r\n            </div>\r\n            <div><strong>Полиморфизм — способность функции обрабатывать данные разных типов.</strong></div>\r\n            <div><strong>Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.</strong></div>\r\n </p>\r\n\r\n<p></p>\r\n<p>Подведем итог.</p>\r\n<p>Смысл ООП - выстраивании гибкой, расширяемой и надежной архитектуры. \r\n    Но основе ООП строится <Link to='/solid'>solid</Link>. Которые повсеместно используются в создании приложений.</p>\r\n</div>\r\n\r\nexport default OOP","import Solid from './solid'\r\nexport default Solid","import React from 'react'\r\n\r\nconst Solid = () =><div>Итак, solid!</div>\r\n\r\nexport default Solid","import Functional from './functional'\r\nexport default Functional","import React from 'react'\r\n\r\nconst Functional = () => <div>\r\n    <h1>Итак, ФП!</h1>\r\n</div>\r\n\r\nexport default Functional","import React from 'react';\nimport './App.css';\nimport {HashRouter as Router, Route, Switch} from 'react-router-dom';\nimport WelcomePage from './components/welcomepage';\nimport Header from './components/header';\nimport OOP from './units/paradigmas/oop';\nimport Solid from './units/principles/solid';\nimport Functional from './units/paradigmas/functional';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nfunction App() {\n  return (\n    <Router>\n        <Switch>\n            <div className='mx-3'>\n                <Header/>\n                <Route path='/' component={WelcomePage} exact />\n                <Route path=\"/oop\" render={()=><OOP/>} />\n                <Route path=\"/func\" render={()=><Functional/>} />\n                <Route path=\"/solid\" render={()=><Solid/>} />\n            </div>\n        </Switch>\n    </Router>\n);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}